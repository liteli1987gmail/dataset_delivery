# --------------------------------------------------------------
# 这是数据研磨的第三步：
# 读取seatable 第一轮指代消解结果
# 分段研磨成一句句话。再并存回seatable
# --------------------------------------------------------------


# # 从 seatable 提取 未处理 的 第一轮研磨数据
# import seatable
# import abab

# 第二轮未处理数据组=seatable.提取第二轮未处理()

# for 当前研磨数据 in 第二轮未处理数据组:
#     # print(当前研磨数据["第一轮指代消解"])    
#     print(当前研磨数据)
#     # --------------------------------------------------------------
#     # 读取seatable 第一轮指代消解结果
#     # 分段研磨成一句句话。再并存回seatable
#     # --------------------------------------------------------------

#     # 当前研磨数据["第一轮指代消解"] 按 \n\n 分段，放入  待处理文本组
#     待处理文本组=当前研磨数据["第一轮指代消解"].split("\n\n")
#     # print(待处理文本组[0])

#     #循环处理待处理文本组，最终结果合并到 最终合并文本
#     最终合并文本=""
#     for 待处理文本 in 待处理文本组:
#         # 如果 txt 里的汉字数量>20 
#         if len([c for c in 待处理文本 if '\u4e00' <= c <= '\u9fff'])>20:
#             # print(待处理文本)
#             # 调用 abab 研磨
#             当前研磨结果=abab.abab研磨(当前研磨数据["新闻时间"],待处理文本)
#             # print(当前研磨结果)
#         else:
#             当前研磨结果=待处理文本

#         最终合并文本=最终合并文本+当前研磨结果+"。"+"\n\n" 

#         row_data = {
#                 "新闻时间": 当前研磨数据['新闻时间'],
#                 "url": 当前研磨数据['url'],
#                 "第二轮研磨结果": 最终合并文本}
#         # print(row_data)
#     print(最终合并文本)
#     seatable.存入第二轮研磨库(row_data)

#     seatable.修改step02_第一轮指代消解里第二轮状态(当前研磨数据["_id"])

#     print(f"--------------- 成功存入第二轮研磨： {当前研磨数据['新闻时间']} ")


# ------------------------------- 并发版本 ---------------------------------
# ------------------------------- 并发版本 ---------------------------------
# ------------------------------- 并发版本 ---------------------------------
# ------------------------------- 并发版本 ---------------------------------
# ------------------------------- 并发版本 ---------------------------------
import seatable
import abab2
from concurrent.futures import ThreadPoolExecutor, as_completed

# 从 seatable 提取未处理的第二轮研磨数据
第二轮未处理数据组 = seatable.提取第二轮未处理()
print(f"第二轮未处理数据组数量：{len(第二轮未处理数据组)}")

# def 处理研磨数据(当前研磨数据):
#     try:
#         # 打印当前研磨数据
#         print(当前研磨数据)

#         # 当前研磨数据["第一轮指代消解"] 按 \n\n 分段，放入待处理文本组
#         待处理文本组 = 当前研磨数据["第一轮指代消解"].split("\n\n")

#         # 循环处理待处理文本组，最终结果合并到最终合并文本
#         最终合并文本 = ""
#         for 待处理文本 in 待处理文本组:
#             # 如果 txt 里的汉字数量>20
#             if len([c for c in 待处理文本 if '\u4e00' <= c <= '\u9fff']) > 20:
#                 # 调用 abab 研磨
#                 当前研磨结果 = abab2.abab研磨(当前研磨数据["新闻时间"], 待处理文本)
#             else:
#                 当前研磨结果 = 待处理文本

#             最终合并文本 = 最终合并文本 + 当前研磨结果 + "。" + "\n\n"

#         row_data = {
#             "新闻时间": 当前研磨数据['新闻时间'],
#             "url": 当前研磨数据['url'],
#             "第二轮研磨结果": 最终合并文本
#         }

#         # 打印最终合并文本
#         print(最终合并文本)
        
#         # 存入第二轮研磨库
#         seatable.存入第二轮研磨库(row_data)
        
#         # 修改第一轮指代消解里的第二轮状态
#         seatable.修改step02_第一轮指代消解里第二轮状态(当前研磨数据["_id"])

#         print(f"--------------- 成功存入第二轮研磨： {当前研磨数据['新闻时间']} ")
#     except Exception as e:
#         print(f"-------------------------------！！！！！！处理研磨数据时发生错误： {e}")
#         exit(0) 

def 处理研磨数据(当前研磨数据):
    # 打印当前研磨数据
    print(当前研磨数据)

    # 当前研磨数据["第一轮指代消解"] 按 \n\n 分段，放入待处理文本组
    待处理文本组 = 当前研磨数据["第一轮指代消解"].split("\n\n")

    # 循环处理待处理文本组，最终结果合并到最终合并文本
    最终合并文本 = ""
    for 待处理文本 in 待处理文本组:
        # 如果 txt 里的汉字数量>20
        if len([c for c in 待处理文本 if '\u4e00' <= c <= '\u9fff']) > 20:
            # 调用 abab 研磨
            当前研磨结果 = abab2.abab研磨(当前研磨数据["新闻时间"], 待处理文本)
        else:
            当前研磨结果 = 待处理文本

        最终合并文本 = 最终合并文本 + 当前研磨结果 + "。" + "\n\n"

    row_data = {
        "新闻时间": 当前研磨数据['新闻时间'],
        "url": 当前研磨数据['url'],
        "第二轮研磨结果": 最终合并文本
    }

    # 打印最终合并文本
    print(最终合并文本)
    
    # 存入第二轮研磨库
    seatable.存入第二轮研磨库(row_data)
    
    # 修改第一轮指代消解里的第二轮状态
    seatable.修改step02_第一轮指代消解里第二轮状态(当前研磨数据["_id"])

    print(f"--------------- 成功存入第二轮研磨： {当前研磨数据['新闻时间']} ")


#循环10次
for _ in range(3):
    # 创建线程池
    with ThreadPoolExecutor(max_workers=1) as executor: 
        # 提交任务
        futures = [executor.submit(处理研磨数据, 当前研磨数据) for 当前研磨数据 in 第二轮未处理数据组]
        
        # 等待所有任务完成
        for future in as_completed(futures):
            future.result()  # 获取任务结果，以便捕获可能的异常


